# Порождающие
Эти паттерны отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов.
  + Фабричный метод
  + Абстрактная фабрика
  + Строитель
  + Прототип
  + Одиночка

## Фабричный метод
Абстракция имеет абстрактный метод создания сущности. Реализация иполняет этот метод каждая по-своему

## Абстрактная фабрика
Позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.

## Строитель
Позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

Каждый строитель уникален и следует интерфейсу того, что он может строить.

Можно добавить в структуру Директора, который будет принимать реализацию строителя и регламентировать порядок сборки

# Структурные
Эти паттерны отвечают за построение удобных в поддержке иерархий классов.
  + Адаптер
  + Мост
  + Компоновщик
  + Декоратор
  + Фасад
  + Легковес
  + Заместитель

## Адаптер
Позволяет объектам с несовместимыми интерфейсами работать вместе.

Обычно используется в уже написанном коде чтобы связать части системы или систему и какую-то новую библиотеку

Адаптер связывает интерфейс стороннего сервиса с интерфейсом клиента так, что клиент не понимает подмены

## Мост
Разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.

Паттерн Мост предлагает заменить наследование агрегацией или композицией. Для этого нужно выделить одну из таких «плоскостей» в отдельную иерархию и ссылаться на объект этой иерархии, вместо хранения его состояния и поведения внутри одного класса.

## Компоновщик
Позволяет сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как будто это единичный объект.

Принцип в том, что в главной точке у всего дерева единый интерфейс. И если нужно узнать что-то внизу дерева клиент не перебирает всё дерево, а спрашивает у главного узла. 
Тот в свою очередь если не может обработать спускает в дочерние узлы и так далее.

## Декоратор
Позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».

Декорируемый объект и декоратор строго следуют одному интерфейсу, поэтому клиентский код не видит подмены. 

Декореруемый объект остается как ссылка на состояние внтури декоратора, декоратор исполняет интерфейс

## Фасад
Предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

Чтобы вынести цепочку последовательных действий из клиентского кода и обособить, следует создавать фасады

## Легковес
Позволяет вместить бóльшее количество объектов в отведённую оперативную память.

Просто хитрая уловка, вместо создания новых объектов в сложных вычислениях выностить их в общее состояние, сокращая количество таких созданий

## Заместитель
Позволяет подставлять вместо реальных объектов специальные объекты-заменители

Очень хорош для ленивых загрузок

# Поведенческие
Эти паттерны решают задачи эффективного и безопасного взаимодействия между объектами программы.
  + Цепочка обязанностей
  + Команда
  + Итератор
  + Посредник
  + Снимок
  + Наблюдатель
  + Состояние
  + Стратегия
  + Шаблонный метод
  + Посетитель

## Цепочка обязанностей
Позволяет передавать запросы последовательно по цепочке обработчиков

Типичные мидлвары в пхп

## Команда
Это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.

1 класс = 1 действие. 

клиент-команда-обработчик

К примеру - консольное и веб создание пользователя можно перенести в один слой, где будет команда CreateUser и обработчики команды.

## Итератор
Даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.

Суть в том, чтобы не заставлять клиентский код каждый раз делать обход коллекции c проверкой условий на своей стороне, 
этот обход будет вынесен в отдельный слой с предоставлением интерфейса к возможностям такого обхода - итератору.

## Посредник (Mediator)
Позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник

Помогает вынести взаимодейтсвие между логически не связанными компонентами системы через посредника для избежания жесткого
связывания между различными по ответственностям компонентами

Ивент диспетчер, например. Посредник для сервисов. Сервисы принимают диспетчер входящей зависимостью, могут ставить, удалять, обрабатывать события. 
Таким образом никто из цепочки не работает друг с другом напрямую. Вся работа происходит через интерфейс посредника - диспетчера событий. 
Диспетчер получает событие и уведомляет подписчиков

## Снимок
Позволяет сохранять и восстанавливать прошлые состояния объектов, не раскрывая подробностей их реализации.

Позволяет делать сохранение состояния объекта. Такая функциональность добавляется владельцу снимка, который может читать все поля, в т.ч. приватные.
Потом сохраняет сам себя и отдает на хранение опекуну(истории). Если нужно объекту возвращают этот снимок и он делает восстановление из него.

## Наблюдатель
Создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.

Паттерн Наблюдатель предлагает хранить внутри объекта издателя список ссылок на объекты подписчиков, причём издатель не должен вести список подписки 
самостоятельно. Он предоставит методы, с помощью которых подписчики могли бы добавлять или убирать себя из списка.

## Состояние
Позволяет объектам менять поведение в зависимости от своего состояния

Основная идея в том, что программа может находиться в одном из нескольких состояний, которые всё время сменяют друг друга. 
Набор этих состояний, а также переходов между ними, предопределён и конечен. 
Находясь в разных состояниях, программа может по-разному реагировать на одни и те же события, которые происходят с ней.

Такой подход можно применить и к отдельным объектам. 
Например, объект Документ может принимать три состояния: Черновик, Модерация или Опубликован. 
В каждом из этих состоянии метод опубликовать будет работать по-разному:

## Стратегия
Определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, 
после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.

## Шаблонный метод
Определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. 
Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры.

## Посетитель
Позволяет добавлять в программу новые операции, не изменяя классы объектов, над которыми эти операции могут выполняться.


