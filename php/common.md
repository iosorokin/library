# Типы данных
  4 скалярных 4 смешанных 2 специальных = 10 + enum + void + mixed ? = 13 ??
  + Скалярные:
    - bool
    - int
    - float (число с плавающей точкой, также известное как double)
    - string
  + смешанного типа:
    - array
    - object
    - callable
    - iterable 
  + сцепиального типа:
    - resource /вроде хотят вывести в будущих версиях?
    - NULL


 # ООП
  + Полиморфи́зм — возможность объектов с одинаковой спецификацией (интерфейсом) иметь различную реализацию.
  + Инкапсуляция — свойство программирования, позволяющее пользователю не задумываться о сложности реализации используемого программного компонента (что у него внутри?), а взаимодействовать с ним посредством предоставляемого интерфейса (публичных методов и членов), а также объединить и защитить жизненно важные для компонента данные. При этом пользователю предоставляется только спецификация (интерфейс) объекта.
  + Абстра́кция  — в объектно-ориентированном программировании это придание объекту характеристик, которые отличают его от всех объектов, четко определяя его концептуальные границы. Основная идея состоит в том, чтобы отделить способ использования составных объектов данных от деталей их реализации в виде более простых объектов, подобно тому, как функциональная абстракция разделяет способ использования функции и деталей её реализации в терминах более примитивных функций, таким образом, данные обрабатываются функцией высокого уровня с помощью вызова функций низкого уровня.
  + Наследование — один из четырёх важнейших механизмов объектно-ориентированного программирования (наряду с инкапсуляцией, полиморфизмом и абстракцией), позволяющий описать новый класс на основе уже существующего (родительского), при этом свойства и функциональность родительского класса заимствуются новым классом.

# Позднее статическое связывание ¶
Само название "позднее статическое связывание" отражает в себе внутреннюю реализацию этой особенности. "Позднее связывание" отражает тот факт, что обращения через static:: не будут вычисляться по отношению к классу, в котором вызываемый метод определён, а будут вычисляться на основе информации в ходе исполнения. Также эта особенность была названа "статическое связывание" потому, что она может быть использована (но не обязательно) в статических методах.

Позднее статическое связывание пытается устранить это ограничение, предоставляя ключевое слово, которое ссылается на класс, вызванный непосредственно в ходе выполнения. Попросту говоря, ключевое слово, которое позволит вам ссылаться на B из test() в предыдущем примере. Было решено не вводить новое ключевое слово, а использовать static, которое уже зарезервировано.

В двух словах: Класс А имеет статическию функцию Х, класс Б наследует А и переопределяет Х. Любой метод из А при обращении self::X будет обращаться с методу в A, а не к переопределенному B. static::X решает эту проблему и обращается к этому методу головного класса.
